# 效率编程 之「创建和销毁对象」

### 第 1 条：考虑用静态工厂方法代替构造器

类可以提供一个公有的静态工厂方法，它只是一个返回类的示例的静态方法。例如，

```
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

- **静态工厂方法与构造器不同的第一大优势在于，它们有名称**。特别地，在构造器的参数不能够清晰地描述正被返回的对象时，那么具适当名称的静态工厂更容易使用。
- **静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象**。静态工厂方法能够为重复的调用返回相同的对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。
- **静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象**。例如在 JDK 1.5 中引入的类`java.util.EnumSet`就没有公有构造器，仅有静态工厂方法，它们返回两种实现类之一，具体则取决于底层枚举类型的大小：如果它的元素有 64 个或者更少，就像大多数枚举类型一样，静态工厂方法就返回一个`RegalarEnumSet`实例，用单个`long`进行支持；如果枚举类型有 65 个或者更多的元素，静态工厂就返回`JumboEnumSet`实例，用`long`数组进行支持。
- **静态工厂方法与构造器不同的第四大优势在于，在创建参数化类型实例的时候，它们使代码变得更加简洁**。例如在调用参数化类的构造器时，即使类型参数很明显，也必须指出，这通常要求我们连续两次提供类型参数：

```
Map<String, List<String>> map = new HashMao<String, List<String>>();
```
如果有以下的静态工厂方法，

```
public static <K, V> HashMap<K, V> newHashMap() {
    return new HashMap<K, V>();
}
```
则上述繁琐的声明，将简化为：

```
Map<String, List<String>> map = Maps.newHashMap();
```
但是很遗憾，在标准的 JDK 中，并没有提供类似的静态工厂方法。不过，我们可以通过在项目中引入谷歌发布的`Guava`，使用上述类似的静态工厂方法。当然，静态工厂方法也不是尽善尽美的，它也有相应的缺点：

- **静态工厂方法的主要缺点在于，类如果不含有公有的或者受保护的构造器，就不能被子类化**；
- **静态工厂方法的第二个缺点在于，它们与其他的静态方法实际上没有任何区别**。

简而言之，静态工厂方法和公有的构造器都各有用处，我们需要理解它们各自的长处。静态工厂方法通常更加合适，因此切记第一反应就是提供公有的构造器，而不是优先考虑静态工厂方法。












----------

———— ☆☆☆ —— 返回 -> [那些年，关于 Java 的那些事儿](https://github.com/guobinhit/java-skills/blob/master/README.md) <- 目录 —— ☆☆☆ ————
