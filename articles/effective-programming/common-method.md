# 效率编程 之「对于所有对象都通用的方法」

### 第 1 条：覆盖`equals`时请遵守通用约定

覆盖`equals`方法看似很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。最容易避免这类问题的办法就是不覆盖`equals`方法，在这种情况下，类的每个实例都只与它自身相等。如果类满足了以下任何一个条件，就不需要我们覆盖`equals`方法：

- 类的每个实例本质上都是唯一的；
- 不关心类是否提供了“逻辑相等”的测试功能；
- 超类已经覆盖了`equals`方法，从超类继承过来的行为对于子类也是合适的；
- 类是私有的或是包级私有的，可以确定它的`equals`方法永远不会被调用。

有一种“值类”不需要覆盖`equals`方法，即用实例受控确保“每个值至多只存在一个对象”的类，如枚举类型。否则的话，如果要覆盖`equals`方法，则需要满足以下等价关系：

- 自反性，对于任何非`null`的引用值`x`，`x.equals(x)`必须返回`true`；
- 对称性，对于任何非`null`的引用值`x`和`y`，当且仅当`x.equals(y)`返回`true`时，`y.equals(x)`必须返回`true`；
- 传递性，对于任何非`null`的引用值`x`、`y`和`z`，如果`x.equals(y)`返回`true`，并且`y.equals(z)`也返回`true`，那么`x.equals(z)`也必须返回`true`；
- 一致性，对于任何非`null`的引用值`x`和`y`，只要`equals()`的比较操作在对象中所用的信息没有被修改，多次调用`x.equals(y)`就会一致地返回`true`，或者一致地返回`false`；
- 对于任何非`null`的引用值`x`，`x.equals(null)`必须返回`fales`.






----------

———— ☆☆☆ —— 返回 -> [那些年，关于 Java 的那些事儿](https://github.com/guobinhit/java-skills/blob/master/README.md) <- 目录 —— ☆☆☆ ————
